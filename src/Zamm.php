<?php

/**
 * This software package is licensed under `AGPL, Commercial` license[s].
 *
 * @package maslosoft/zamm
 * @license AGPL, Commercial
 *
 * @copyright Copyright (c) Peter Maselkowski <pmaselkowski@gmail.com>
 * @link https://maslosoft.com/zamm/
 */

namespace Maslosoft\Zamm;

use Maslosoft\EmbeDi\EmbeDi;
use Maslosoft\Zamm\Interfaces\ConverterInterface;
use Maslosoft\Zamm\Converters\PhpConverter;
use Maslosoft\Zamm\Decorators\StarRemover;
use Maslosoft\Zamm\Extractors\AddendumExtractor;
use Maslosoft\Zamm\Interfaces\Extractors\ExtractorInterface;
use Maslosoft\Zamm\Extractors\NullExtractor;
use Maslosoft\Zamm\Interfaces\FileDecoratorInterface;
use Maslosoft\Zamm\FileDecorators\IgnoreFileDecorator;
use Maslosoft\Zamm\FileDecorators\MadeByFileDecorator;
use Maslosoft\Zamm\Interfaces\SourceAccessorInterface;
use Maslosoft\Zamm\Outputs\FileOutput;
use Maslosoft\Zamm\Interfaces\OutputInterface;
use Maslosoft\Zamm\Renderers\ClassRenderer;
use Maslosoft\Zamm\Interfaces\Renderers\ClassRendererInterface;
use Maslosoft\Zamm\Interfaces\Renderers\MethodRendererInterface;
use Maslosoft\Zamm\Interfaces\Renderers\PropertyRendererInterface;
use Maslosoft\Zamm\Interfaces\Renderers\RendererInterface;
use Maslosoft\Zamm\Renderers\MethodRenderer;
use Maslosoft\Zamm\Renderers\PropertyRenderer;

/**
 * Zamm: PHP Doc extractor for code fragments
 * This class allows extracting code fragments into documentation.
 * It is designed to be IDE friendly. It should autocomplete and automatically reflect code refactors if properly used.
 * This documentation is also processed with Zamm.
 *
 * @author Piotr Maselkowski <pmaselkowski at gmail.com>
 */
class Zamm implements SourceAccessorInterface
{

	use Traits\SourceMagic;

	/**
	 * @deprecated
	 * TODO See if it's used somewhere
	 */ 
	public const Version = '1.0.0';
	public const MadeBy = 'Generated by Maslosoft Zamm';
	public const DefaultInstanceId = 'zamm';

	/**
	 * Input for documentation
	 * Array of folders and files to process.
	 * @var string[]
	 */
	public $input = [
		'docs'
	];

	public $output = [

	];

	/**
	 * Configuration of decorators.
	 * This should be array with keys of renderer interface names and values of decorator classes.
	 * @var string[][]
	 */
	public $decorators = [
		// All around decorators
		RendererInterface::class => [
			StarRemover::class
		],
		// Class decorators
		ClassRendererInterface::class => [
		],
		// Property decorators
		PropertyRendererInterface::class => [
		],
		// Method decorators
		MethodRendererInterface::class => [
		],
	];

	/**
	 * Configuration of file decorators.
	 * This should be array with keys of converter names and values of file decorator classes.
	 * @var string[][]
	 */
	public $fileDecorators = [
		// All file decorators
		FileDecoratorInterface::class => [
			MadeByFileDecorator::class
		],
		// PHP converter decorators
		PhpConverter::class => [
			IgnoreFileDecorator::class
		]
	];

	/**
	 * Converters
	 * Array of class names of converters. These will be applied in order specified here, to all files.
	 * All converters should implement `IConverter` interface.
	 * @see ConverterInterface
	 * @var string[]
	 */
	public $converters = [
		PhpConverter::class
	];

	/**
	 * Outputs classes
	 * Array of class names of outputs. These will be applied in order specified here, to all files.
	 * All outputs should implement `IOutput` interface.
	 * @see OutputInterface
	 * @var string[]
	 */
	public $outputs = [
		FileOutput::class
	];

	/**
	 * Extractor class name.
	 * This class will be used to extract source fragments. Defaults to `AddendumExtractor`.
	 * It implements `IExtractor` interface.
	 * @see AddendumExtractor
	 * @see ExtractorInterface
	 * @var string
	 */
	public $extractor = AddendumExtractor::class;

	/**
	 * Extractor instance
	 * @var ExtractorInterface
	 */
	private $_extractor = null;

	/**
	 * Working class name
	 * @var string|null
	 */
	private $_className = '';

	/**
	 * EmbeDi instance
	 * @var ?EmbeDi
	 */
	private ?EmbeDi $_di = null;

	public function __construct($className = null)
	{
		$this->_className = $className;
		if(class_exists(EmbeDi::class))
		{
			$this->_di = new EmbeDi(self::DefaultInstanceId);
			$this->_di->configure($this);
		}
	}

	public function init()
	{
		if(class_exists(EmbeDi::class))
		{
			$this->_di->store($this);
		}
	}

	public function methods()
	{
		/**
		 * TODO Return all method names
		 */
	}

	public function properties()
	{
		/**
		 * TODO Return all property names
		 */
	}

	public function method($name)
	{
		return new MethodRenderer($this->getExtractor(), $name);
	}

	public function property($name)
	{
		return new PropertyRenderer($this->getExtractor(), $name);
	}

	public function setExtractor(ExtractorInterface $extractor)
	{
		$this->_extractor = $extractor;
	}

	public function getExtractor()
	{
		if (null === $this->_extractor)
		{

			if (!$this->_className)
			{
				$extractorClass = NullExtractor::class;
			}
			else
			{
				$extractorClass = $this->extractor;
			}
			$extractor = new $extractorClass();
			$extractor->setClassName($this->_className);
			$this->_extractor = $extractor;
		}
		return $this->_extractor;
	}

	public static function __callStatic($name, $arguments)
	{
		$className = get_called_class();
		return new MethodRenderer((new Zamm($className))->getExtractor(), $name);
	}

	/**
	 *
	 * @return ClassRenderer
	 */
	public function __toString()
	{
		return (string) new ClassRenderer($this->getExtractor());
	}

}
